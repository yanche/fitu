
var path = require('path');
var bluebird = require('bluebird');
var mime = require('mime');
var extension = require('extension');
var http = require('http');
var FileCacher = require('./FileCacher.js');
var CachedFile = require('./CachedFile.js');

var noCompressMime = [new RegExp('^image'), new RegExp('^font')];
var noCacheMime = [new RegExp('^image')];

var needGzip = function (mime) {
    return noCompressMime.every(function (n) { return !n.test(mime); });
};

var needCache = function (mime) {
    return noCacheMime.every(function (n) { return !n.test(mime); });
};

var _gzip = {
    regex: /\bgzip\b/,
    head: 'gzip'
};

var FileService = function (options) {
    this.options = options || {};
    this.options.wdir = this.options.wdir || __dirname;
    
    this.fileCacher = new FileCacher();
};

FileService.prototype.handle = function (webreq) {
    var me = this;
    var filename = path.join(me.options.wdir, webreq.pathname);
    return extension.file.fileLastModified(filename)
    .then(function (modi) {
        var fileModifiedOn = modi.getTime();
        var ims = new Date(webreq._raw.headers['if-modified-since']).getTime();
        if (isNaN(ims) || fileModifiedOn != ims) {
            return bluebird.resolve()
            .then(function () {
                var cachedFile = me.fileCacher.get(webreq.pathname);
                if (cachedFile && cachedFile.modifiedOn === fileModifiedOn)
                    return cachedFile;
                else {
                    //1:cache file(no compression for font files). 2:do not cache image
                    var newCachedFile = new CachedFile();
                    return newCachedFile.load(filename, needGzip)
                    .then(function () {
                        if (needCache(newCachedFile.mime)) {
                            //cache file
                            me.fileCacher.set(webreq.pathname, newCachedFile);
                            console.log('static file: ' + webreq.pathname + ' cached, ' + (newCachedFile.gzip ? 'compressed' : 'not compressed'));
                        }
                        return newCachedFile;
                    });
                }
            })
            .then(function (cachedFile) {
                var retHeaders = {}, content;
                retHeaders['Last-Modified'] = new Date(cachedFile.modifiedOn).toUTCString();
                retHeaders['Cache-Control'] = 'public, max-age=' + extension.datetime.getFileMaxAge();
                if (cachedFile.gzip && _gzip.regex.test(webreq._raw.headers['accept-encoding'] || '')) {
                    retHeaders['Content-Encoding'] = _gzip.head;
                    content = cachedFile.gzip;
                }
                else {
                    content = cachedFile.raw;
                }
                return extension.http.webres200(cachedFile.mime, content, retHeaders);
            });
        }
        else {
            return extension.http.webres304({ 'Cache-Control': 'public, max-age=' + extension.datetime.getFileMaxAge() });
        }
    })
    .catch(function (err) {
        return extension.http.webres404();
    })
};


module.exports = FileService;