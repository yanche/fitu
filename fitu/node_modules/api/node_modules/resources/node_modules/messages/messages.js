
var db = require('dbaccess');
var bluebird = require('bluebird');
var extension = require('extension');
var constants = require('const');
var imageUpload = require('imageUpload');
var errdef = require('errdef');
var resxutil = require('resxutil');
var config = require('config');
var Resource = require('resource');
var validate = require('validate');
var _ = require('underscore');
var infra = require('infra');

/*
list: [{
'id':,
'targetType':,
'targetId':,
'words':,
'authorId':,
'replyToMsgId':,
'replyToUserId':,
'createdOn':,
'like': [ array of user id]
}],
total:
*/
var Messages = function (webreq) {
    var me = this;
    Resource.call(this, webreq);
    me.filter.targetType = webreq.search.targetType;
    me.filter.targetObjId = extension.mongo.tryConvObjId(webreq.search.targetId);
    //me.badFilter = webreq.search.targetId && !me.filter.targetObjId;
    me.pageSize = extension.pagination.convPageSize(webreq.search.pageSize, config.pageSize.message.max, config.pageSize.message.min, config.pageSize.message.default);
    me.page = extension.pagination.convPage(webreq.search.page); //page starts from 0
};

Messages.prototype = Object.create(Resource.prototype);

Messages.prototype._accessibility = function () {
    var httpOptions = new resxutil.HttpOptions();
    var me = this;
    if (!constants.message.validType(me.filter.targetType) || !me.filter.targetObjId)
        return bluebird.resolve(httpOptions.setStatus('GET', 400).setStatus('POST', 400));
    else if (!me.operator)
        return bluebird.resolve(httpOptions.setStatus('GET', 200).setStatus('POST', 401));
    else {
        return me.operator.isGodOrOb()
        .then(function (ok) {
            //god nor ob can send message
            return httpOptions.setStatus('GET', 200).setStatus('POST', ok ? 401 : 200);
        });
    }
};

Messages.prototype._get = function () {
    var me = this, messages = null, total = 0;
    return me._accessibility()
    .then(function (httpOptions) {
        var status = httpOptions.getStatus('GET');
        if (status.isOK()) {
            var filter = { targetType: me.filter.targetType, targetId: me.filter.targetObjId };
            return bluebird.all([
                db.message.getMessagesFieldsInPage(filter, resxutil.message.getFields, { createdOn: -1 }, me.page * me.pageSize, me.pageSize),
                db.message.countMessages(filter)
            ]);
        }
        else
            throw new errdef.DeferChainKiller(status.toWebres());
    })
    .then(function (data) {
        messages = data[0], total = data[1];
        var relatedUsers = [];
        messages.forEach(function (m) { relatedUsers.push(m.authorId); if(m.replyToUserId) relatedUsers.push(m.replyToUserId); })
        //TODO: much less information of author, no phone.. maybe only nickName and headUrl
        return db.user.getUsersFieldsBy({ _id: { $in: relatedUsers } }, resxutil.user.getRelatedUserFields);
    })
    .then(function (relatedUsers) {
        return messages.map(function (msg) { return resxutil.message.convMsgInfo(msg, relatedUsers, me.operator ? me.operator.objId : null); });
    })
    .then(function (data) {
        return extension.http.webres200(constants.mime.json, JSON.stringify({ list: data, total: total }));
    })
    .catch(errdef.DeferChainKiller, function (err) {
        return err.attach;
    });
};

Messages.prototype._post = function () {
    var me = this;
    return me._accessibility()
    .then(function (httpOptions) {
        var status = httpOptions.getStatus('POST');
        if (status.isOK()) {
            //TODO: make this more generic
            switch (me.filter.targetType) {
                case constants.message.types.activity:
                    return db.activity.getOneActFieldsBy({ '_id': me.filter.targetObjId }, { '_id': 1 });
                case constants.message.types.site:
                    return db.site.getOneSiteFieldsBy({ '_id': me.filter.targetObjId }, { '_id': 1 });
                case constants.message.types.vendor:
                    return db.vendor.getOneVendorFieldsBy({ '_id': me.filter.targetObjId }, { '_id': 1 });
                default:
                    throw new errdef.DeferChainKiller(extension.http.webres400());
            }
        }
        else
            throw new errdef.DeferChainKiller(status.toWebres());
    })
    .then(function (ok) {
        if (ok) {
            if (me.args.replyToId) {
                var replyToObjId = extension.mongo.tryConvObjId(me.args.replyToId);
                if (!replyToObjId)
                    throw new errdef.DeferChainKiller(extension.http.webres400());
                else
                    return db.message.getOneMessageFieldsBy({ '_id': replyToObjId }, { '_id': 1, 'authorId': 1 });
            }
            else
                return true;
        }
        else
            throw new errdef.DeferChainKiller(extension.http.webres400()); //target object not found
    })
    .then(function (replyMsg) {
        if (replyMsg) {
            var create = {
                createdOn: new Date(), targetType: me.filter.targetType, targetId: me.filter.targetObjId,
                authorId: me.operator.objId, like: []
            };
            //reply to some message, not just pass-by in last pipe node
            if (replyMsg !== true) {
                create.replyToMsgId = replyMsg._id;
                create.replyToUserId = replyMsg.authorId;
            }
            if (validate.valuedString(me.args.words))
                create.words = me.args.words;
            else
                throw new errdef.DeferChainKiller(extension.http.webres400()); //TODO: no 'enter': /r/n
            return db.message.insertOneMessage(create);
        }
        else
            throw new errdef.DeferChainKiller(extension.http.webres400()); //replyTo user not found
    })
    .then(function (inserted) {
        return extension.http.webres200(constants.mime.plain, '', { Location: '/messages?id=' + inserted._id.toString() });
    })
    .catch(errdef.DeferChainKiller, function (err) {
        return err.attach;
    });
};

module.exports = Messages;