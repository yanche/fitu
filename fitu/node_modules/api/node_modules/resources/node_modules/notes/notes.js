
var db = require('dbaccess');
var bluebird = require('bluebird');
var extension = require('extension');
var constants = require('const');
var errdef = require('errdef');
var resxutil = require('resxutil');
var config = require('config');
var Resource = require('resource');
var infra = require('infra');
var _ = require('underscore');
var validate = require('validate');

/*
{
'id':,
'type':,
'author':,
'createdOn':,
'recipients': [],
'subject':,
'content': [],
'emphasis':,
}
*/
var Notes = function (webreq) {
    var me = this;
    Resource.call(this, webreq);
    me.filter.authorObjId = extension.mongo.tryConvObjId(webreq.search.authorId);
    me.filter.recipientObjId = extension.mongo.tryConvObjId(webreq.search.recipientId);
    me.filter.actObjId = extension.mongo.tryConvObjId(webreq.search.actId);
    me.filter.sys = Boolean(webreq.search.sys);
    me.badFilter = (webreq.search.authorId && !me.filter.authorObjId) || (webreq.search.recipientId && !me.filter.recipientObjId) || (webreq.search.actId && !me.filter.actObjId);
    me.pageSize = extension.pagination.convPageSize(webreq.search.pageSize, config.pageSize.notes.max, config.pageSize.notes.min, config.pageSize.notes.default);
    me.page = extension.pagination.convPage(webreq.search.page); //page starts from 0
};

Notes.prototype = Object.create(Resource.prototype);

Notes.prototype._accessibility = function () {
    var httpOptions = new resxutil.HttpOptions(), me = this;
    //POST
    if (me.filter.recipientObjId || me.filter.actObjId)
        httpOptions.setStatus('POST', me.operator ? 200 : 401);
    else
        httpOptions.setStatus('POST', 400);
    //GET
    if (me.badFilter || (!me.filter.authorObjId && !me.filter.recipientObjId))
        return bluebird.resolve(httpOptions.setStatus('GET', 400));
    else if (!me.operator)
        return bluebird.resolve(httpOptions.setStatus('GET', 401));
    else {
        return me.operator.isGodOrOb()
        .then(function (ok) {
            if (ok)
                return httpOptions.setStatus('GET', 200).setStatus('POST', 401);
            else if (me.operator.objId.equals(me.filter.authorObjId) || me.operator.objId.equals(me.filter.recipientObjId))
                return httpOptions.setStatus('GET', 200);
            else
                return httpOptions.setStatus('GET', 401);
        });
    }
};

Notes.prototype._get = function () {
    var me = this, notes = null, total = 0;
    return me._accessibility()
    .then(function (httpOptions) {
        var status = httpOptions.getStatus('GET');
        if (status.isOK()) {
            var filter = {};
            if (me.filter.authorObjId)
                filter.authorId = me.filter.authorObjId;
            if (me.filter.recipientObjId)
                filter.recipients = me.filter.recipientObjId; //one of
            if (me.filter.sys)
                filter.type = constants.note.types.system;
            else
                filter.type = constants.note.types.note;
            return bluebird.all([
                db.note.getNotesFieldsInPage(filter, resxutil.note.getFields, { createdOn: -1 }, me.page * me.pageSize, me.pageSize),
                db.note.countNotes(filter)
            ]);
        }
        else
            throw new errdef.DeferChainKiller(status.toWebres());
    })
    .then(function (data) {
        notes = data[0], total = data[1];
        var relatedUsers = [];
        notes.forEach(function (n) { relatedUsers.push(n.authorId); relatedUsers.push(n.recipients); })
        return db.user.getUsersFieldsBy({ _id: { $in: _.flatten(relatedUsers) } }, resxutil.user.getRelatedUserFields);
    })
    .then(function (relatedUsers) {
        return notes.map(function (note) { return resxutil.note.convNoteInfo(note, relatedUsers); });
    })
    .then(function (data) {
        return extension.http.webres200(constants.mime.json, JSON.stringify({ list: data, total: total }));
    })
    .catch(errdef.DeferChainKiller, function (err) {
        return err.attach;
    });
};

Notes.prototype._post = function () {
    var me = this;
    return me._accessibility()
    .then(function (httpOptions) {
        var status = httpOptions.getStatus('POST');
        if (status.isOK()) {
            if (me.filter.recipientObjId) {
                return db.user.getOneUserFieldsBy({ _id: me.filter.recipientObjId }, { _id: 1 })
                .then(function (receiver) {
                    if (receiver)
                        return [receiver._id];
                    else
                        throw new errdef.DeferChainKiller(extension.http.webres404());
                });
            }
            else if (me.filter.actObjId) {
                return me.operator.activityWritable(me.filter.actObjId)
                .then(function (ok) {
                    if (ok) {
                        return db.member.getMembersFieldsBy({ actId: me.filter.actObjId }, { userId: 1 })
                        .then(function (mems) {
                            if (mems.length > 0)
                                return extension.array.uniqueObjIdArray(mems.map(function (m) { return m.userId; }));
                            else
                                throw new errdef.DeferChainKiller(extension.http.webres404());
                        });
                    }
                    else
                        throw new errdef.DeferChainKiller(extension.http.webres401());
                });
            }
            else
                throw new errdef.DeferChainKiller(extension.http.webres400());
        }
        else
            throw new errdef.DeferChainKiller(status.toWebres());
    })
    .then(function (receivers) {
        var create = { type: constants.note.types.note, createdOn: new Date(), authorId: me.operator.objId, recipients: receivers, emphasis: Boolean(me.args.emphasis), body: { type: constants.note.contentTypes.plain }, subject: { type: constants.note.contentTypes.plain } };
        if (validate.valuedString(me.args.subject))
            create.subject.content = me.args.subject;
        else
            throw new errdef.DeferChainKiller(extension.http.webres400()); //TODO: no 'enter': /r/n
        create.body.content = me.args.body; //TODO: content
        return db.note.insertOneNote(create);
    })
    .then(function (inserted) {
        return extension.http.webres200(constants.mime.plain, '', { Location: '/notes?id=' + inserted._id.toString() });
    })
    .catch(errdef.DeferChainKiller, function (err) {
        return err.attach;
    });
};

module.exports = Notes;